import 'package:flutter/gestures.dart';
import 'package:flutter/material.dart';
import 'package:flutter/rendering.dart';

/// The [GestureType] enumeration provides a way to specify the type of gesture
/// used to interact with the [PannableRatingBar.onChanged] callback.
/// When set to [GestureType.tapOnly], only tap events are accepted.
/// On the other hand, when set to [GestureType.tapAndDrag], both tap and drag
/// events are supported.
enum GestureType {
  tapOnly,
  tapAndDrag,
}

/// Configuration for widget used as a rate widget.
class RatingWidget {
  const RatingWidget({
    this.selectedColor = Colors.yellow,
    this.unSelectedColor,
    required this.child,
  });

  /// Specifies the custom widget to be used as the rating indicator. The
  /// [child] can be of any size, shape, or type and does not have to be similar
  /// to other indicators. The [selectedColor] and [unSelectedColor] will be
  /// drawn on the [child].
  final Widget child;

  /// The [selectedColor] property specifies the color that will be drawn on
  /// [child] to indicate the current selection. It defaults to [Colors.yellow].
  final Color selectedColor;

  /// The color used for the unselected portion of the rating, which will be
  /// drawn below [selectedColor]. By default, this is set to null, meaning the
  /// background color filter layer will not be drawn. If you wish to specify a
  /// color, simply set this property to the desired color.
  final Color? unSelectedColor;
}

/// Signature for function that return a [RatingWidget], used in
/// [PannableRatingBar.builder]
typedef IndexedRatingWidgetBuilder = RatingWidget Function(BuildContext, int);

/// A stateless rating bar widget that supports tap, pan (drag) and hover
/// events, with no limits on the value of [PannableRatingBar.rate]. The value
/// is distributed to each [RatingWidget.child] respectively.

/// The value is reported through the [PannableRatingBar.onChanged] callback for
/// tap or drag event and can be used as desired.

/// Similarly, the value is reported through the [PannableRatingBar.onHover]
/// callback for hover event and can be used as desired.

/// This widget uses Flutter's [Wrap] layout and supports all its properties.
/// For more information on these properties, refer to the [Wrap] documentation.
/// It also takes [Wrap.textDirection] and [Wrap.verticalDirection] into account
/// during drawing.
class PannableRatingBar extends StatelessWidget {
  /// Constructs a [PannableRatingBar] widget with a required [rate] and a list
  /// of [RatingWidget] items.
  /// If multiple items have similar features, consider using
  /// [PannableRatingBar.builder].
  /// The items do not have to be the same, and each item can have its own
  /// unique size, shape, etc.
  const PannableRatingBar({
    Key? key,
    required this.rate,
    required List<RatingWidget> items,
    this.onChanged,
    this.onHover,
    this.direction = Axis.horizontal,
    this.alignment = WrapAlignment.center,
    this.spacing = 0,
    this.runAlignment = WrapAlignment.center,
    this.runSpacing = 0,
    this.crossAxisAlignment = WrapCrossAlignment.start,
    this.textDirection,
    this.verticalDirection = VerticalDirection.down,
    this.clipBehavior = Clip.none,
    this.enablePixelsCompensation = true,
    this.minRating,
    this.maxRating,
    this.gestureType = GestureType.tapAndDrag,
  })  : _useItemBuilder = false,
        _items = items,
        _itemCount = items.length,
        _itemBuilder = null,
        super(key: key);

  /// Construct a [PannableRatingBar] using a builder function. This constructor
  /// allows you to generate each item on-demand, which can be useful if many of
  /// the items are similar.
  /// The items generated by [itemBuilder] can have different size, shape, etc.
  ///
  /// The required parameters for this constructor are [itemBuilder] and
  /// [itemCount]. [itemBuilder] takes in an index and returns a [RatingWidget].
  /// [itemCount] is the number of items the builder should generate.
  const PannableRatingBar.builder({
    Key? key,
    required this.rate,
    required IndexedRatingWidgetBuilder itemBuilder,
    required int itemCount,
    this.onChanged,
    this.onHover,
    this.direction = Axis.horizontal,
    this.alignment = WrapAlignment.center,
    this.spacing = 0,
    this.runAlignment = WrapAlignment.center,
    this.runSpacing = 0,
    this.crossAxisAlignment = WrapCrossAlignment.start,
    this.textDirection,
    this.verticalDirection = VerticalDirection.down,
    this.clipBehavior = Clip.none,
    this.enablePixelsCompensation = true,
    this.minRating,
    this.maxRating,
    this.gestureType = GestureType.tapAndDrag,
  })  : _useItemBuilder = true,
        _items = null,
        _itemCount = itemCount,
        _itemBuilder = itemBuilder,
        super(key: key);

  /// The current rating value of this widget, which will be correctly
  /// distributed for all [RatingWidget.child] children.
  final double rate;

  /// The callback is triggered each time there's a new value of [rate]
  /// that is received through a tap or drag pointer event.
  /// This callback only reports the next value, to actually change the visual
  /// appearance of the widget, it needs to be rebuilt with the new [rate]
  /// value.
  final ValueChanged<double>? onChanged;

  /// The callback is triggered whenever the mouse hovers over the rating
  /// widgets. It reports the rate value at that pointer position.
  /// This callback only reports the next value, to actually change the visual
  /// appearance of the widget, it needs to be rebuilt with the new [rate]
  /// value.
  final ValueChanged<double>? onHover;

  /// A flag to determine whether the child widgets will have a margin of 1px
  /// or not.
  /// This is a workaround for an issue in Flutter
  /// (https://github.com/flutter/flutter/issues/98464).
  final bool enablePixelsCompensation;

  /// The minimum value to be considered when callbacks are fired. The callbacks
  /// will be skipped if the incoming value is smaller than [minRating].
  final double? minRating;

  /// The maximum value to be considered when callbacks are fired. The callbacks
  /// will be skipped if the incoming value is bigger than [maxRating].
  final double? maxRating;

  /// Specifies the gesture [PannableRatingBar.onChanged] will respond to.
  /// Default to [GestureType.tapAndDrag].
  final GestureType gestureType;

  /// Refer to [Wrap.direction]
  final Axis direction;

  /// Refer to [Wrap.alignment]
  final WrapAlignment alignment;

  /// Refer to [Wrap.spacing]
  final double spacing;

  /// Refer to [Wrap.runAlignment]
  final WrapAlignment runAlignment;

  /// Refer to [Wrap.runSpacing]
  final double runSpacing;

  /// Refer to [Wrap.crossAxisAlignment]
  final WrapCrossAlignment crossAxisAlignment;

  /// Refer to [Wrap.textDirection]
  final TextDirection? textDirection;

  /// Refer to [Wrap.verticalDirection]
  final VerticalDirection verticalDirection;

  /// Refer to [Wrap.clipBehavior]
  final Clip clipBehavior;

  // private properties used to store data needed of each constructor
  // respectively.
  final bool _useItemBuilder;
  final List<RatingWidget>? _items;
  final IndexedRatingWidgetBuilder? _itemBuilder;
  final int _itemCount;

  /// Retrieves the current number of [RatingWidget]s in this rating bar.
  int get itemCount => _itemCount;

  /// Calculates the distribution of the [rate] value among each of the
  /// [RatingWidget]s.
  double calcPercent(int index, double rate) {
    if (index < rate.floor()) {
      return 1;
    }
    if (index >= rate) {
      return 0;
    }
    return (rate - rate.floor()).clamp(0, 1);
  }

  @override
  Widget build(BuildContext context) {
    final List<_RateItem> children = [];
    for (var i = 0; i < itemCount; i++) {
      RatingWidget config;
      if (_useItemBuilder) {
        config = _itemBuilder!.call(context, i);
      } else {
        config = _items![i];
      }
      Widget child = config.child;
      if (enablePixelsCompensation) {
        child = Container(
          margin: const EdgeInsets.all(1),
          child: child,
        );
      }
      children.add(_RateItem(
        key: ValueKey<int>(i),
        percent: calcPercent(i, rate),
        selectedColor: config.selectedColor,
        unSelectedColor: config.unSelectedColor,
        axis: direction,
        textDirection: textDirection,
        verticalDirection: verticalDirection,
        child: child,
      ));
    }
    return _PannableWrap(
      direction: direction,
      alignment: alignment,
      spacing: spacing,
      runAlignment: runAlignment,
      runSpacing: runSpacing,
      crossAxisAlignment: crossAxisAlignment,
      textDirection: textDirection,
      verticalDirection: verticalDirection,
      clipBehavior: clipBehavior,
      onChanged: onChanged,
      onHover: onHover,
      maxRating: maxRating,
      minRating: minRating,
      gestureType: gestureType,
      children: children,
    );
  }
}

class _PannableWrap extends Wrap {
  _PannableWrap({
    required Axis direction,
    required WrapAlignment alignment,
    required double spacing,
    required WrapAlignment runAlignment,
    required double runSpacing,
    required WrapCrossAlignment crossAxisAlignment,
    required TextDirection? textDirection,
    required VerticalDirection verticalDirection,
    required Clip clipBehavior,
    required List<Widget> children,
    required this.onChanged,
    required this.gestureType,
    this.maxRating,
    this.minRating,
    this.onHover,
  }) : super(
          direction: direction,
          alignment: alignment,
          spacing: spacing,
          runAlignment: runAlignment,
          runSpacing: runSpacing,
          crossAxisAlignment: crossAxisAlignment,
          textDirection: textDirection,
          verticalDirection: verticalDirection,
          clipBehavior: clipBehavior,
          children: children,
        );
  final ValueChanged<double>? onChanged;
  final double? minRating;
  final double? maxRating;
  final GestureType gestureType;
  final ValueChanged<double>? onHover;

  @override
  RenderWrap createRenderObject(BuildContext context) {
    return _RenderPannableWrap(
      direction: direction,
      alignment: alignment,
      spacing: spacing,
      runAlignment: runAlignment,
      runSpacing: runSpacing,
      crossAxisAlignment: crossAxisAlignment,
      textDirection: textDirection ?? Directionality.maybeOf(context),
      verticalDirection: verticalDirection,
      clipBehavior: clipBehavior,
      onChanged: onChanged,
      maxRating: maxRating,
      minRating: minRating,
      gestureType: gestureType,
      onHover: onHover,
    );
  }

  @override
  void updateRenderObject(
      BuildContext context, _RenderPannableWrap renderObject) {
    renderObject
      ..direction = direction
      ..alignment = alignment
      ..spacing = spacing
      ..runAlignment = runAlignment
      ..runSpacing = runSpacing
      ..crossAxisAlignment = crossAxisAlignment
      ..textDirection = textDirection ?? Directionality.maybeOf(context)
      ..verticalDirection = verticalDirection
      ..clipBehavior = clipBehavior
      ..onChanged = onChanged
      ..maxRating = maxRating
      ..minRating = minRating
      ..gestureType = gestureType
      ..onHover = onHover;
  }
}

class _RenderPannableWrap extends RenderWrap {
  _RenderPannableWrap({
    List<RenderBox>? children,
    Axis direction = Axis.horizontal,
    WrapAlignment alignment = WrapAlignment.start,
    double spacing = 0.0,
    WrapAlignment runAlignment = WrapAlignment.start,
    double runSpacing = 0.0,
    WrapCrossAlignment crossAxisAlignment = WrapCrossAlignment.start,
    TextDirection? textDirection,
    VerticalDirection verticalDirection = VerticalDirection.down,
    Clip clipBehavior = Clip.none,
    required this.gestureType,
    this.maxRating,
    this.minRating,
    this.onChanged,
    this.onHover,
  }) : super(
          children: children,
          direction: direction,
          alignment: alignment,
          spacing: spacing,
          runAlignment: runAlignment,
          runSpacing: runSpacing,
          crossAxisAlignment: crossAxisAlignment,
          textDirection: textDirection,
          verticalDirection: verticalDirection,
          clipBehavior: clipBehavior,
        ) {
    final team = GestureArenaTeam();
    _tap = TapGestureRecognizer(debugOwner: this);
    _tap
      ..team = team
      ..onTapDown = (details) {
        _onChange(details.localPosition);
      };
    _drag = PanGestureRecognizer(debugOwner: this)
      ..team = team
      ..onStart = (details) {
        _onChange(details.localPosition);
      }
      ..onUpdate = (details) {
        _onChange(details.localPosition);
      };
  }

  ValueChanged<double>? onChanged;
  ValueChanged<double>? onHover;

  late final TapGestureRecognizer _tap;
  late final PanGestureRecognizer _drag;

  double? minRating;
  double? maxRating;
  GestureType gestureType;

  late bool validForMouseTracker;

  double? _hitTestRatingValue(Offset position) {
    _RenderRateItem? child = firstChild as _RenderRateItem?;
    final result = BoxHitTestResult();
    int childIndex = 0;
    double? percent;
    while (child != null) {
      final WrapParentData childParentData =
          child.parentData! as WrapParentData;
      final bool isHit = result.addWithPaintOffset(
        offset: childParentData.offset,
        position: position,
        hitTest: (BoxHitTestResult result, Offset transformed) {
          final isHit = child!.hitTest(result, position: transformed);
          if (isHit) {
            percent = child._percentHitTest(position: transformed);
          }
          return isHit;
        },
      );
      if (isHit && percent != null) {
        final rounded =
            double.parse((childIndex + percent!).toStringAsFixed(1));
        if (minRating != null && rounded < minRating!) return null;
        if (maxRating != null && rounded > maxRating!) return null;
        return rounded;
      }
      childIndex += 1;
      child = childParentData.nextSibling as _RenderRateItem?;
    }
    return null;
  }

  void _onChange(Offset position) {
    double? value = _hitTestRatingValue(position);
    if (value != null) {
      onChanged?.call(value);
    }
  }

  void _onHover(Offset position) {
    double? value = _hitTestRatingValue(position);
    if (value != null) {
      onHover?.call(value);
    }
  }

  @override
  void handleEvent(
      PointerEvent event, covariant HitTestEntry<HitTestTarget> entry) {
    if (event is PointerDownEvent && onChanged != null) {
      bool useTap = true;
      bool useDrag = true;
      switch (gestureType) {
        case GestureType.tapOnly:
          useDrag = false;
          break;
        case GestureType.tapAndDrag:
        default:
          break;
      }
      if (useDrag) {
        _drag.addPointer(event);
      }
      if (useTap) {
        _tap.addPointer(event);
      }
    }
    if (event is PointerHoverEvent && onHover != null) {
      _onHover(event.localPosition);
    }
  }

  @override
  void dispose() {
    _tap.dispose();
    _drag.dispose();
    super.dispose();
  }
}

class _RateItem extends SingleChildRenderObjectWidget {
  const _RateItem({
    Key? key,
    required Widget child,
    required this.percent,
    required this.selectedColor,
    required this.unSelectedColor,
    required this.axis,
    this.textDirection,
    required this.verticalDirection,
  })  : assert(percent >= 0 && percent <= 1),
        super(
          key: key,
          child: child,
        );
  final Color selectedColor;
  final Color? unSelectedColor;
  final double percent;
  final Axis axis;
  final TextDirection? textDirection;
  final VerticalDirection verticalDirection;

  @override
  RenderObject createRenderObject(BuildContext context) {
    return _RenderRateItem(
      selectedColor: selectedColor,
      unSelectedColor: unSelectedColor,
      percent: percent,
      axis: axis,
      textDirection: textDirection ?? Directionality.maybeOf(context),
      verticalDirection: verticalDirection,
    );
  }

  @override
  void updateRenderObject(
      BuildContext context, covariant _RenderRateItem renderObject) {
    renderObject
      ..percent = percent
      ..selectedColor = selectedColor
      ..unSelectedColor = unSelectedColor
      ..axis = axis
      ..verticalDirection = verticalDirection
      ..textDirection = textDirection ?? Directionality.maybeOf(context);
  }
}

class _RenderRateItem extends RenderProxyBox {
  _RenderRateItem({
    required Color selectedColor,
    required Color? unSelectedColor,
    required double percent,
    required Axis axis,
    required TextDirection? textDirection,
    required VerticalDirection verticalDirection,
  })  : _selectedColor = selectedColor,
        _unSelectedColor = unSelectedColor,
        _percent = percent,
        _axis = axis,
        _textDirection = textDirection,
        _verticalDirection = verticalDirection;

  VerticalDirection _verticalDirection;

  VerticalDirection get verticalDirection => _verticalDirection;

  set verticalDirection(VerticalDirection value) {
    if (value != _verticalDirection) {
      _verticalDirection = value;
      markNeedsPaint();
    }
  }

  TextDirection? _textDirection;

  TextDirection? get textDirection => _textDirection;

  set textDirection(TextDirection? value) {
    if (value != _textDirection) {
      _textDirection = value;
      markNeedsPaint();
    }
  }

  Axis _axis;

  Axis get axis => _axis;

  set axis(Axis value) {
    if (_axis != value) {
      _axis = value;
      markNeedsPaint();
    }
  }

  Color _selectedColor;

  Color get selectedColor => _selectedColor;

  set selectedColor(Color value) {
    if (_selectedColor != value) {
      _selectedColor = value;
      markNeedsPaint();
    }
  }

  Color? _unSelectedColor;

  Color? get unSelectedColor => _unSelectedColor;

  set unSelectedColor(Color? value) {
    if (value != _unSelectedColor) {
      _unSelectedColor = value;
      markNeedsPaint();
    }
  }

  double _percent;

  double get percent => _percent;

  set percent(double value) {
    if (_percent != value) {
      _percent = value;
      markNeedsPaint();
    }
  }

  double? _percentHitTest({required Offset position}) {
    if (size.contains(position)) {
      double result;
      switch (axis) {
        case Axis.horizontal:
          result = position.dx / size.width;
          if (textDirection == TextDirection.rtl) {
            result = 1 - result;
          }
          break;
        case Axis.vertical:
          result = position.dy / size.height;
          if (verticalDirection == VerticalDirection.up) {
            result = 1 - result;
          }
          break;
      }
      return result;
    }
    return null;
  }

  void _paintBackground(PaintingContext context, Offset offset,
      PaintingContextCallback paintChild) {
    assert(unSelectedColor != null);
    _backgroundHandle.layer ??= ColorFilterLayer();
    _backgroundHandle.layer!.colorFilter = ColorFilter.mode(
      unSelectedColor!,
      BlendMode.srcIn,
    );

    context.pushLayer(_backgroundHandle.layer!, paintChild, offset);
  }

  void _paintForeground(PaintingContext context, Offset offset,
      PaintingContextCallback paintChild) {
    double width = 0.0;
    double height = 0.0;
    if (axis == Axis.horizontal) {
      width = size.width * percent;
      height = size.height;
    } else {
      width = size.width;
      height = size.height * percent;
    }
    final maskSize = Size(
      width,
      height,
    );

    Rect maskRect = offset & maskSize;
    if (textDirection == TextDirection.rtl && axis == Axis.horizontal) {
      maskRect = maskRect.shift(Offset(size.width - maskRect.width, 0));
    } else if (verticalDirection == VerticalDirection.up &&
        axis == Axis.vertical) {
      maskRect = maskRect.shift(Offset(0, size.height - maskRect.height));
    }

    _foregroundHandle.layer ??= ShaderMaskLayer();
    _foregroundHandle.layer!
      ..shader = LinearGradient(
              tileMode: TileMode.decal, colors: [selectedColor, selectedColor])
          .createShader(Offset.zero & maskSize)
      ..maskRect = maskRect
      ..blendMode = BlendMode.srcIn;
    context.pushLayer(_foregroundHandle.layer!, paintChild, offset);
  }

  @override
  bool get alwaysNeedsCompositing => true;

  @override
  void dispose() {
    _backgroundHandle.layer = null;
    _foregroundHandle.layer = null;
    super.dispose();
  }

  @override
  void paint(PaintingContext context, Offset offset) {
    assert(child != null);
    assert(needsCompositing);
    if (unSelectedColor != null) {
      _paintForeground(context, offset, (context, offset) {
        _paintBackground(context, offset, super.paint);
      });
    } else {
      _backgroundHandle.layer = null;
      _paintForeground(context, offset, super.paint);
    }
  }

  final LayerHandle<ColorFilterLayer> _backgroundHandle =
      LayerHandle<ColorFilterLayer>();
  final LayerHandle<ShaderMaskLayer> _foregroundHandle =
      LayerHandle<ShaderMaskLayer>();
}
